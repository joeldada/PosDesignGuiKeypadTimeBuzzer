
// Glcd module connections

#define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function
#define leftSide 1
#define rightSide 66

#define ON  1
#define OFF 0

#define YES 1
#define NO  0

#define buzzer PORTC.F2
char  keypadPort at PORTB;

char GLCD_DataPort at PORTD;

sbit GLCD_CS2 at RC4_bit;
sbit GLCD_CS1 at RC5_bit;
sbit GLCD_RS  at RA1_bit;
sbit GLCD_RW  at RA2_bit;
sbit GLCD_EN  at RC3_bit;
sbit GLCD_RST at RA0_bit;

sbit GLCD_CS2_Direction at TRISC4_bit;
sbit GLCD_CS1_Direction at TRISC5_bit;
sbit GLCD_RS_Direction  at TRISA1_bit;
sbit GLCD_RW_Direction  at TRISA2_bit;
sbit GLCD_EN_Direction  at TRISC3_bit;
sbit GLCD_RST_Direction at TRISA0_bit;
// End Glcd module connections


sbit Soft_I2C_Scl           at RC0_bit;
sbit Soft_I2C_Sda           at RC1_bit;
sbit Soft_I2C_Scl_Direction at TRISC0_bit;
sbit Soft_I2C_Sda_Direction at TRISC1_bit;

char uart_rd;
   unsigned char uart_data, counter, kp, kpp[5];
   unsigned char cmd;
   unsigned char start_data;
   unsigned char end_data;
   unsigned char data1[40];
   unsigned char data3[20];
   unsigned char data2[5];
   unsigned char isCommand = 0;
   unsigned char isStartData = 0;
   unsigned char isEndData = 0;
   unsigned char countuart = 0;
   int ii;


unsigned short sec;
unsigned short minute;
unsigned short hour;
unsigned short day;
unsigned short date;
unsigned short month;
unsigned short year;
unsigned short dataa;
char time[9];
char ddate[11];


unsigned char display[1024] = {0};
                                       /*
const unsigned char TEXT[95][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 32
                         0x00, 0x00, 0x5F, 0x00, 0x00, // !      33
                         0x00, 0x03, 0x00, 0x03, 0x00, // "      34
                         0x14, 0x3E, 0x14, 0x3E, 0x14, // #      35
                         0x24, 0x2A, 0x7F, 0x2A, 0x12, // $     36
                         0x43, 0x33, 0x08, 0x66, 0x61, // %     37
                         0x36, 0x49, 0x55, 0x22, 0x50, // &       38
                         0x00, 0x05, 0x03, 0x00, 0x00, // '         39
                         0x00, 0x1C, 0x22, 0x41, 0x00, // (           40
                         0x00, 0x41, 0x22, 0x1C, 0x00, // )41
                         0x14, 0x08, 0x3E, 0x08, 0x14, // *  42
                         0x08, 0x08, 0x3E, 0x08, 0x08, // +    43
                         0x00, 0x50, 0x30, 0x00, 0x00, // ,      44
                         0x08, 0x08, 0x08, 0x08, 0x08, // -        45
                         0x00, 0x60, 0x60, 0x00, 0x00, // .          46
                         0x20, 0x10, 0x08, 0x04, 0x02, // /            47
                         0x3E, 0x51, 0x49, 0x45, 0x3E, // 0              48
                         0x04, 0x02, 0x7F, 0x00, 0x00, // 1                49
                         0x42, 0x61, 0x51, 0x49, 0x46, // 2                  50
                         0x22, 0x41, 0x49, 0x49, 0x36, // 3 51
                         0x18, 0x14, 0x12, 0x7F, 0x10, // 4   52
                         0x27, 0x45, 0x45, 0x45, 0x39, // 5     53
                         0x3E, 0x49, 0x49, 0x49, 0x32, // 6       54
                         0x01, 0x01, 0x71, 0x09, 0x07, // 7         55
                         0x36, 0x49, 0x49, 0x49, 0x36, // 8           56
                         0x26, 0x49, 0x49, 0x49, 0x3E, // 9             57
                         0x00, 0x36, 0x36, 0x00, 0x00, // :               58
                         0x00, 0x56, 0x36, 0x00, 0x00, // ;                 59
                         0x08, 0x14, 0x22, 0x41, 0x00, // <                   60
                         0x14, 0x14, 0x14, 0x14, 0x14, // = 61
                         0x00, 0x41, 0x22, 0x14, 0x08, // >   62
                         0x02, 0x01, 0x51, 0x09, 0x06, // ?     63
                         0x3E, 0x41, 0x59, 0x55, 0x5E, // @       64
                         0x7E, 0x09, 0x09, 0x09, 0x7E, // A         65
                         0x7F, 0x49, 0x49, 0x49, 0x36, // B           66
                         0x3E, 0x41, 0x41, 0x41, 0x22, // C             67
                         0x7F, 0x41, 0x41, 0x41, 0x3E, // D               68
                         0x7F, 0x49, 0x49, 0x49, 0x41, // E                 69
                         0x7F, 0x09, 0x09, 0x09, 0x01, // F                   70
                         0x3E, 0x41, 0x41, 0x49, 0x3A, // G 71
                         0x7F, 0x08, 0x08, 0x08, 0x7F, // H   72
                         0x00, 0x41, 0x7F, 0x41, 0x00, // I     73
                         0x30, 0x40, 0x40, 0x40, 0x3F, // J       74
                         0x7F, 0x08, 0x14, 0x22, 0x41, // K         75
                         0x7F, 0x40, 0x40, 0x40, 0x40, // L           76
                         0x7F, 0x02, 0x0C, 0x02, 0x7F, // M             77
                         0x7F, 0x02, 0x04, 0x08, 0x7F, // N               78
                         0x3E, 0x41, 0x41, 0x41, 0x3E, // O                 79
                         0x7F, 0x09, 0x09, 0x09, 0x06, // P                   80
                         0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 81
                         0x7F, 0x09, 0x09, 0x09, 0x76,// R    82

//const unsigned char TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S
                         0x26, 0x49, 0x49, 0x49, 0x32, // S     83
                         0x01, 0x01, 0x7F, 0x01, 0x01, // T       84
                         0x3F, 0x40, 0x40, 0x40, 0x3F, // U         85
                         0x1F, 0x20, 0x40, 0x20, 0x1F, // V           86
                         0x7F, 0x20, 0x10, 0x20, 0x7F, // W             87
                         0x41, 0x22, 0x1C, 0x22, 0x41, // X               88
                         0x07, 0x08, 0x70, 0x08, 0x07, // Y                 89
                         0x61, 0x51, 0x49, 0x45, 0x43, // Z                   90
                         0x00, 0x7F, 0x41, 0x00, 0x00, // [ 91
                         0x02, 0x04, 0x08, 0x10, 0x20, // \   92
                         0x00, 0x00, 0x41, 0x7F, 0x00, // ]     93
                         0x04, 0x02, 0x01, 0x02, 0x04, // ^       94
                         0x40, 0x40, 0x40, 0x40, 0x40, // _         95
                         0x00, 0x01, 0x02, 0x04, 0x00, // `           96
                         0x20, 0x54, 0x54, 0x54, 0x78, // a             97
                         0x7F, 0x44, 0x44, 0x44, 0x38, // b               98
                         0x38, 0x44, 0x44, 0x44, 0x44, // c                 99
                         0x38, 0x44, 0x44, 0x44, 0x7F, // d                   100
                         0x38, 0x54, 0x54, 0x54, 0x18, // e 101
                         0x04, 0x04, 0x7E, 0x05, 0x05, // f    102
                         0x08, 0x54, 0x54, 0x54, 0x3C, // g       103
                         0x7F, 0x08, 0x04, 0x04, 0x78, // h          104
                         0x00, 0x44, 0x7D, 0x40, 0x00, // i             105
                         0x20, 0x40, 0x44, 0x3D, 0x00, // j                106
                         0x7F, 0x10, 0x28, 0x44, 0x00, // k                   107
                         0x00, 0x41, 0x7F, 0x40, 0x00, // l                      108
                         0x7C, 0x04, 0x78, 0x04, 0x78, // m                         109
                         0x7C, 0x08, 0x04, 0x04, 0x78, // n                            110
                         0x38, 0x44, 0x44, 0x44, 0x38, // o 111
                         0x7C, 0x14, 0x14, 0x14, 0x08, // p    112
                         0x08, 0x14, 0x14, 0x14, 0x7C, // q       113
                         0x00, 0x7C, 0x08, 0x04, 0x04, // r          114
                         0x48, 0x54, 0x54, 0x54, 0x20, // s             115
                         0x04, 0x04, 0x3F, 0x44, 0x44, // t                116
                         0x3C, 0x40, 0x40, 0x20, 0x7C, // u                   117
                         0x1C, 0x20, 0x40, 0x20, 0x1C, // v                      118
                         0x3C, 0x40, 0x30, 0x40, 0x3C, // w                         119
                         0x44, 0x28, 0x10, 0x28, 0x44, // x                            120
                         0x0C, 0x50, 0x50, 0x50, 0x3C, // y 121
                         0x44, 0x64, 0x54, 0x4C, 0x44, // z    122
                         0x00, 0x08, 0x36, 0x41, 0x41, // {       123
                         0x00, 0x00, 0x7F, 0x00, 0x00, // |          124
                         0x41, 0x41, 0x36, 0x08, 0x00, // }             125
                         0x02, 0x01, 0x02, 0x04, 0x02};// ~                126
                                     */

const unsigned char TEXT[96][5] =   {
        0x00, 0x00, 0x00, 0x00, 0x00,// (space)
        0x00, 0x00, 0x5F, 0x00, 0x00,// !
        0x00, 0x07, 0x00, 0x07, 0x00,// "
        0x14, 0x7F, 0x14, 0x7F, 0x14,// #
        0x24, 0x2A, 0x7F, 0x2A, 0x12,// $
        0x23, 0x13, 0x08, 0x64, 0x62,// %
        0x36, 0x49, 0x55, 0x22, 0x50,// &
        0x00, 0x05, 0x03, 0x00, 0x00,// '
        0x00, 0x1C, 0x22, 0x41, 0x00,// (
        0x00, 0x41, 0x22, 0x1C, 0x00,// )
        0x08, 0x2A, 0x1C, 0x2A, 0x08,// *
        0x08, 0x08, 0x3E, 0x08, 0x08,// +
        0x00, 0x50, 0x30, 0x00, 0x00,// ,
        0x08, 0x08, 0x08, 0x08, 0x08,// -
        0x00, 0x30, 0x30, 0x00, 0x00,// .
        0x20, 0x10, 0x08, 0x04, 0x02,// /
        0x3E, 0x51, 0x49, 0x45, 0x3E,// 0
        0x00, 0x42, 0x7F, 0x40, 0x00,// 1
        0x42, 0x61, 0x51, 0x49, 0x46,// 2
        0x21, 0x41, 0x45, 0x4B, 0x31,// 3
        0x18, 0x14, 0x12, 0x7F, 0x10,// 4
        0x27, 0x45, 0x45, 0x45, 0x39,// 5
        0x3C, 0x4A, 0x49, 0x49, 0x30,// 6
        0x01, 0x71, 0x09, 0x05, 0x03,// 7
        0x36, 0x49, 0x49, 0x49, 0x36,// 8
        0x06, 0x49, 0x49, 0x29, 0x1E,// 9
        0x00, 0x36, 0x36, 0x00, 0x00,// :
        0x00, 0x56, 0x36, 0x00, 0x00,// ;
        0x00, 0x08, 0x14, 0x22, 0x41,// <
        0x14, 0x14, 0x14, 0x14, 0x14,// =
        0x41, 0x22, 0x14, 0x08, 0x00,// >
        0x02, 0x01, 0x51, 0x09, 0x06,// ?
        0x32, 0x49, 0x79, 0x41, 0x3E,// @
        0x7E, 0x11, 0x11, 0x11, 0x7E,// A
        0x7F, 0x49, 0x49, 0x49, 0x36,// B
        0x3E, 0x41, 0x41, 0x41, 0x22,// C
        0x7F, 0x41, 0x41, 0x22, 0x1C,// D
        0x7F, 0x49, 0x49, 0x49, 0x41,// E
        0x7F, 0x09, 0x09, 0x01, 0x01,// F
        0x3E, 0x41, 0x41, 0x51, 0x32,// G
        0x7F, 0x08, 0x08, 0x08, 0x7F,// H
        0x00, 0x41, 0x7F, 0x41, 0x00,// I
        0x20, 0x40, 0x41, 0x3F, 0x01,// J
        0x7F, 0x08, 0x14, 0x22, 0x41,// K
        0x7F, 0x40, 0x40, 0x40, 0x40,// L
        0x7F, 0x02, 0x04, 0x02, 0x7F,// M
        0x7F, 0x04, 0x08, 0x10, 0x7F,// N
        0x3E, 0x41, 0x41, 0x41, 0x3E,// O
        0x7F, 0x09, 0x09, 0x09, 0x06,// P
        0x3E, 0x41, 0x51, 0x21, 0x5E,// Q
        0x7F, 0x09, 0x19, 0x29, 0x46,// R
        0x46, 0x49, 0x49, 0x49, 0x31,// S
        0x01, 0x01, 0x7F, 0x01, 0x01,// T
        0x3F, 0x40, 0x40, 0x40, 0x3F,// U
        0x1F, 0x20, 0x40, 0x20, 0x1F,// V
        0x7F, 0x20, 0x18, 0x20, 0x7F,// W
        0x63, 0x14, 0x08, 0x14, 0x63,// X
        0x03, 0x04, 0x78, 0x04, 0x03,// Y
        0x61, 0x51, 0x49, 0x45, 0x43,// Z
        0x00, 0x00, 0x7F, 0x41, 0x41,// [
        0x02, 0x04, 0x08, 0x10, 0x20,// "\"
        0x41, 0x41, 0x7F, 0x00, 0x00,// ]
        0x04, 0x02, 0x01, 0x02, 0x04,// ^
        0x40, 0x40, 0x40, 0x40, 0x40,// _
        0x00, 0x01, 0x02, 0x04, 0x00,// `
        0x20, 0x54, 0x54, 0x54, 0x78,// a
        0x7F, 0x48, 0x44, 0x44, 0x38,// b
        0x38, 0x44, 0x44, 0x44, 0x20,// c
        0x38, 0x44, 0x44, 0x48, 0x7F,// d
        0x38, 0x54, 0x54, 0x54, 0x18,// e
        0x08, 0x7E, 0x09, 0x01, 0x02,// f
        0x08, 0x14, 0x54, 0x54, 0x3C,// g
        0x7F, 0x08, 0x04, 0x04, 0x78,// h
        0x00, 0x44, 0x7D, 0x40, 0x00,// i
        0x20, 0x40, 0x44, 0x3D, 0x00,// j
        0x00, 0x7F, 0x10, 0x28, 0x44,// k
        0x00, 0x41, 0x7F, 0x40, 0x00,// l
        0x7C, 0x04, 0x18, 0x04, 0x78,// m
        0x7C, 0x08, 0x04, 0x04, 0x78,// n
        0x38, 0x44, 0x44, 0x44, 0x38,// o
        0x7C, 0x14, 0x14, 0x14, 0x08,// p
        0x08, 0x14, 0x14, 0x18, 0x7C,// q
        0x7C, 0x08, 0x04, 0x04, 0x08,// r
        0x48, 0x54, 0x54, 0x54, 0x20,// s
        0x04, 0x3F, 0x44, 0x40, 0x20,// t
        0x3C, 0x40, 0x40, 0x20, 0x7C,// u
        0x1C, 0x20, 0x40, 0x20, 0x1C,// v
        0x3C, 0x40, 0x30, 0x40, 0x3C,// w
        0x44, 0x28, 0x10, 0x28, 0x44,// x
        0x0C, 0x50, 0x50, 0x50, 0x3C,// y
        0x44, 0x64, 0x54, 0x4C, 0x44,// z
        0x00, 0x08, 0x36, 0x41, 0x00,// {
        0x00, 0x00, 0x7F, 0x00, 0x00,// |
        0x00, 0x41, 0x36, 0x08, 0x00,// }
        0x08, 0x08, 0x2A, 0x1C, 0x08,// ->
        0x08, 0x1C, 0x2A, 0x08, 0x08 // <-
        };

const unsigned char TEXT2[95][8] =           {
          0,   0,   0,   0,   0,   0,   0,   0, //' '
          0,   6,  95,  95,   6,   0,   0,   0, //'!'
          0,   7,   7,   0,   7,   7,   0,   0, //'"'
         20, 127, 127,  20, 127, 127,  20,   0, //'#'
         36,  46, 107, 107,  58,  18,   0,   0, //'$'
         70, 102,  48,  24,  12, 102,  98,   0, //'%'
         48, 122,  79,  93,  55, 122,  72,   0, //'&'
          4,   7,   3,   0,   0,   0,   0,   0, //'''
          0,  28,  62,  99,  65,   0,   0,   0, //'('
          0,  65,  99,  62,  28,   0,   0,   0, //')'
          8,  42,  62,  28,  28,  62,  42,   8, //'*'
          8,   8,  62,  62,   8,   8,   0,   0, //'+'
          0, 128, 224,  96,   0,   0,   0,   0, //','
          8,   8,   8,   8,   8,   8,   0,   0, //'-'
          0,   0,  96,  96,   0,   0,   0,   0, //'.'
         96,  48,  24,  12,   6,   3,   1,   0, //'/'
         62, 127, 113,  89,  77, 127,  62,   0, //'0'
         64,  66, 127, 127,  64,  64,   0,   0, //'1'
         98, 115,  89,  73, 111, 102,   0,   0, //'2'
         34,  99,  73,  73, 127,  54,   0,   0, //'3'
         24,  28,  22,  83, 127, 127,  80,   0, //'4'
         39, 103,  69,  69, 125,  57,   0,   0, //'5'
         60, 126,  75,  73, 121,  48,   0,   0, //'6'
          3,   3, 113, 121,  15,   7,   0,   0, //'7'
         54, 127,  73,  73, 127,  54,   0,   0, //'8'
          6,  79,  73, 105,  63,  30,   0,   0, //'9'
          0,   0, 102, 102,   0,   0,   0,   0, //':'
          0, 128, 230, 102,   0,   0,   0,   0, //';'
          8,  28,  54,  99,  65,   0,   0,   0, //'<'
         36,  36,  36,  36,  36,  36,   0,   0, //'='
          0,  65,  99,  54,  28,   8,   0,   0, //'>'
          2,   3,  81,  89,  15,   6,   0,   0, //'?'
         62, 127,  65,  93,  93,  31,  30,   0, //'@'
        124, 126,  19,  19, 126, 124,   0,   0, //'A'
         65, 127, 127,  73,  73, 127,  54,   0, //'B'
         28,  62,  99,  65,  65,  99,  34,   0, //'C'
         65, 127, 127,  65,  99,  62,  28,   0, //'D'
         65, 127, 127,  73,  93,  65,  99,   0, //'E'
         65, 127, 127,  73,  29,   1,   3,   0, //'F'
         28,  62,  99,  65,  81, 115, 114,   0, //'G'
        127, 127,   8,   8, 127, 127,   0,   0, //'H'
          0,  65, 127, 127,  65,   0,   0,   0, //'I'
         48, 112,  64,  65, 127,  63,   1,   0, //'J'
         65, 127, 127,   8,  28, 119,  99,   0, //'K'
         65, 127, 127,  65,  64,  96, 112,   0, //'L'
        127, 127,  14,  28,  14, 127, 127,   0, //'M'
        127, 127,   6,  12,  24, 127, 127,   0, //'N'
         28,  62,  99,  65,  99,  62,  28,   0, //'O'
         65, 127, 127,  73,   9,  15,   6,   0, //'P'
         30,  63,  33, 113, 127,  94,   0,   0, //'Q'
         65, 127, 127,   9,  25, 127, 102,   0, //'R'
         38, 111,  77,  89, 115,  50,   0,   0, //'S'
          3,  65, 127, 127,  65,   3,   0,   0, //'T'
        127, 127,  64,  64, 127, 127,   0,   0, //'U'
         31,  63,  96,  96,  63,  31,   0,   0, //'V'
        127, 127,  48,  24,  48, 127, 127,   0, //'W'
         67, 103,  60,  24,  60, 103,  67,   0, //'X'
          7,  79, 120, 120,  79,   7,   0,   0, //'Y'
         71,  99, 113,  89,  77, 103, 115,   0, //'Z'
          0, 127, 127,  65,  65,   0,   0,   0, //'['
          1,   3,   6,  12,  24,  48,  96,   0, //'\'
          0,  65,  65, 127, 127,   0,   0,   0, //']'
          8,  12,   6,   3,   6,  12,   8,   0, //'^'
        128, 128, 128, 128, 128, 128, 128, 128, //'_'
          0,   0,   3,   7,   4,   0,   0,   0, //'`'
         32, 116,  84,  84,  60, 120,  64,   0, //'a'
         65, 127,  63,  72,  72, 120,  48,   0, //'b'
         56, 124,  68,  68, 108,  40,   0,   0, //'c'
         48, 120,  72,  73,  63, 127,  64,   0, //'d'
         56, 124,  84,  84,  92,  24,   0,   0, //'e'
         72, 126, 127,  73,   3,   2,   0,   0, //'f'
        152, 188, 164, 164, 248, 124,   4,   0, //'g'
         65, 127, 127,   8,   4, 124, 120,   0, //'h'
          0,  68, 125, 125,  64,   0,   0,   0, //'i'
         96, 224, 128, 128, 253, 125,   0,   0, //'j'
         65, 127, 127,  16,  56, 108,  68,   0, //'k'
          0,  65, 127, 127,  64,   0,   0,   0, //'l'
        124, 124,  24,  56,  28, 124, 120,   0, //'m'
        124, 124,   4,   4, 124, 120,   0,   0, //'n'
         56, 124,  68,  68, 124,  56,   0,   0, //'o'
        132, 252, 248, 164,  36,  60,  24,   0, //'p'
         24,  60,  36, 164, 248, 252, 132,   0, //'q'
         68, 124, 120,  76,   4,  28,  24,   0, //'r'
         72,  92,  84,  84, 116,  36,   0,   0, //'s'
          0,   4,  62, 127,  68,  36,   0,   0, //'t'
         60, 124,  64,  64,  60, 124,  64,   0, //'u'
         28,  60,  96,  96,  60,  28,   0,   0, //'v'
         60, 124, 112,  56, 112, 124,  60,   0, //'w'
         68, 108,  56,  16,  56, 108,  68,   0, //'x'
        156, 188, 160, 160, 252, 124,   0,   0, //'y'
         76, 100, 116,  92,  76, 100,   0,   0, //'z'
          8,   8,  62, 119,  65,  65,   0,   0, //'{'
          0,   0,   0, 119, 119,   0,   0,   0, //'|'
         65,  65, 119,  62,   8,   8,   0,   0, //'}
          2,   3,   1,   3,   2,   3,   1,   0, //'~'
          };


const unsigned char TEXT3[65][3] =           {
        0x00,0x00,0x00, //* Espace       0x20 */
        0x00,0x17,0x00, //* ! */
        0x03,0x00,0x03, //* " */
        0x1F,0x0A,0x1F, //* # */
        0x1F,0x11,0x1F, //* $ */
        0x09,0x04,0x12, //* % */
        0x28,0x54,0x08, //* & */
        0x00,0x0C,0x00, //* ' */
        0x38,0x44,0x00, //* ( */
        0x44,0x38,0x00, //* ) */
        0x20,0x10,0x08, //* / */
        0x10,0x38,0x10, //* + */
        0x80,0x40,0x00, //* , */
        0x10,0x10,0x10, //* - */
        0x00,0x40,0x00, //* . */
        0x20,0x10,0x08, //* / */
        0x38,0x44,0x38, //* 0    0x30 */
        0x00,0x7C,0x00, //* 1 */
        0x64,0x54,0x48, //* 2 */
        0x44,0x54,0x28, //* 3 */
        0x1C,0x10,0x7C, //* 4 */
        0x4C,0x54,0x24, //* 5 */
        0x38,0x54,0x20, //* 6 */
        0x04,0x74,0x0C, //* 7 */
        0x28,0x54,0x28, //* 8 */
        0x08,0x54,0x38, //* 9 */
        0x00,0x50,0x00, //* : */
        0x80,0x50,0x00, //* ; */
        0x10,0x28,0x44, //* < */
        0x28,0x28,0x28, //* = */
        0x44,0x28,0x10, //* > */
        0x04,0x54,0x08, //* ? */
        0x38,0x4C,0x5C, //* @    0x40 */
        0x78,0x14,0x78, //* A */
        0x7C,0x54,0x28, //* B */
        0x38,0x44,0x44, //* C */
        0x7C,0x44,0x38, //* D */
        0x7C,0x54,0x44, //* E */
        0x7C,0x14,0x04, //* F */
        0x38,0x44,0x34, //* G */
        0x7C,0x10,0x7C, //* H */
        0x00,0x7C,0x00, //* I */
        0x20,0x40,0x3C, //* J */
        0x7C,0x10,0x6C, //* K */
        0x7C,0x40,0x40, //* L */
        0x7C,0x08,0x7C, //* M */
        0x7C,0x04,0x7C, //* N */
        0x7C,0x44,0x7C, //* O */
        0x7C,0x14,0x08, //* P    0x50 */
        0x38,0x44,0x78, //* Q */
        0x7C,0x14,0x68, //* R */
        0x48,0x54,0x24, //* S */
        0x04,0x7C,0x04, //* T */
        0x7C,0x40,0x7C, //* U */
        0x3C,0x40,0x3C, //* V */
        0x7C,0x20,0x7C, //* W */
        0x6C,0x10,0x6C, //* X */
        0x1C,0x60,0x1C, //* Y */
        0x64,0x54,0x4C, //* Z */
        0x7C,0x44,0x00, //* [ */
        0x08,0x10,0x20, //* \ */
        0x44,0x7C,0x00, //* ] */
        0x08,0x04,0x08, //* ^ */
        0x80,0x80,0x80, //* _ */
        0x04,0x08,0x00  //* `     0x60 */
        };

const unsigned char Quickteller[1024] = {
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 192, 128,   0,   0,   0,   0, 240, 252, 254, 255, 255, 254, 254, 252, 240,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0, 128, 192, 224, 224, 240, 240, 240, 240, 224, 192, 128,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   3,  31, 124, 248, 224, 199,  31,  63,  63,  63,  63,  31,  15,   3,   0, 128,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0, 128, 248, 254,  63,   7,   1,   0,   0,   0,   0,   1, 199, 255, 255,   0,   0,   0, 128, 128,   0,   0,   0,   0,   0, 128, 128,   0,   0,   0,   0, 132, 135,   7,   0,   0,   0,   0,   0, 128, 128, 128, 128,   0,   0,   0,   0, 240, 255,  31,   0,   0,   0,   0, 128, 128,   0,   0,   0,   0,   1,   7,  31, 127, 254, 252, 248, 248, 252,  62,  15,   3,   0,   0,   0, 128, 128, 252, 252, 128, 128,   0,   0,   0,   0,   0, 128, 128, 128,   0,   0,   0,   0,   0,   0, 224, 255,  63,   0,   0,   0,   0, 252, 255,   7,   0,   0,   0,   0,   0,   0, 128, 128, 128,   0,   0,   0,   0,   0,   0, 128, 128,   0,   0, 128, 128, 128,   0,
128, 255, 255,  15,   0,   0,   0,   0,   0,   0,   0, 224, 255, 255,   7,   0,   0, 240, 255,  31,   0,   0,   0,   0, 224, 255,  63,   0,   0,   0, 252, 255,   7,   0,   0, 240, 252,  30,   7,   3,   3,   7,  15,   7,   0,   0, 248, 255, 135, 192, 240, 248,  30,  15,   3,   1,   0,   0,   0,   0,   0,   0, 128, 224, 240, 249, 251, 225,   0,   0,   0,   0,   0,   0,   0, 227, 255,  63,   3,   3,   1,   0, 240, 252, 142, 135, 131, 131, 135, 255, 254,   0,   0,   0, 240, 255,  31,   0,   0,   0,   0, 254, 255,   3,   0,   0, 128, 248, 252, 143, 135, 131, 131, 135, 255, 254,   0,   0,   0, 248, 255,  31,   6,   3,   3,   7,   7,   1,
 31, 255, 255, 224,   0, 128, 192,   0, 224, 240, 124,  63,  15,   1,   0,   0, 120, 255, 255, 192, 128, 192, 192, 240, 255,  31,   0,   0, 128, 254, 255,   3,   0,   0,  63, 255, 225, 192, 128, 128, 192, 224,   0,   0,   0, 252, 255,  15,   3,   1,  31, 255, 252, 192,   0,   0,   0,   0,   0, 224, 248, 254, 255, 255, 255, 255, 255, 255, 254, 224,   0,   0,   0,   0, 112, 255, 255, 128, 128,   0,   0, 127, 255, 227, 193, 129, 129, 193, 225,  65,   1,   0,   0, 248, 255, 207, 128,   0,   0,   0, 255, 255, 193, 128,   0,   0, 127, 255, 225, 129, 129, 129, 193, 225,  65,   1,   0,   0, 252, 255,   7,   0,   0,   0,   0,   0,   0,   0,
  0,   0, 129, 241, 126,  31,  31,  63, 112,   1,   0,   0,   0,   0,   0,   0,   0,   1,   3,   3,   3,   1,   0,   3,   1,   0,   0,   0,   1,   1,   1,   0,   0,   0,   0,   0,   1,   3,   3,   1,   1,   0,   0,   0,   1,   1,   1,   0,   0,   0,   0,   1,   1,   1,   0,   0, 224, 252, 255, 255, 127,  31,  15,   7,   3,   3,   7,  15,  63, 255, 248,   0,   0,   0,   0,   1,   1,   1,   0,   0,   0,   0,   1,   1,   3,   3,   3,   1,   0,   0,   0,   0,   0,   0,   1,   1,   1,   0,   0,   0,   1,   1,   1,   1,   0,   0,   0,   1,   1,   3,   3,   1,   1,   0,   0,   0,   0,   0,   1,   1,   0,   0,   0,   0,   0,   0,   0,   0,
  0,  28,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 192, 248, 255,  63,  15,   3,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,  60,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  96,  62,   7,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0
};

const unsigned char Verve[1024] = {
  0,   0,   0,   0,   0,   0, 128, 192, 192, 224, 240, 240, 248, 248, 252, 252, 252, 254, 254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 254, 254, 254, 254, 252, 252, 252, 248, 248, 240, 224, 224, 192, 128,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0, 192, 240, 248, 254, 255, 255, 255, 255, 255, 255, 255, 253, 249, 243, 243, 227, 199,   7,  13,  11,  19,  39,  71, 207, 143,  31,  63,  63, 127, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 252, 248, 224, 128,   0,   0,   0,   0,
252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 252, 248, 224, 128,   0,   1,   3,   4,  24, 112, 192,   1, 131, 199,  67,  99,  35,  51,  19,  27,  27, 139, 201, 205, 231, 103, 119,  51, 159, 223, 223, 239, 239, 239, 239,  15,  15,  31, 255, 255, 255, 223, 255,  15,  15,  15, 207, 255, 127, 191, 159,  15,  15, 143, 223, 223, 223, 207,  15,  15,  31, 255, 255, 255, 255, 255, 255, 223, 143,  15,  31, 255, 255, 255, 255, 127, 127,  63, 159, 223, 207, 239, 239, 239, 239,  15,  15,  31, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 248,   0,   0,   0,
  1,  31, 127, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 240,   0,   0,   0,   0,   1,   1, 128, 192, 224, 240, 248, 252, 254, 254, 255, 255,  15,   3,   1,   0, 224, 246, 247, 247, 247, 243, 251, 249, 252, 124, 254, 255, 255, 255, 127,  15,   1, 128, 224, 242, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254,   0,   0,   0, 127, 127, 191, 223, 231, 243, 249, 252, 255, 255,  15,   3,   0,   0, 252, 247, 247, 247, 247, 243, 251, 249, 124, 124, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 127,  63,   7,   1,   0,   0,   0,
  0,   0,   0,   0,   1,   7,  15,  15,  31,  63, 127, 127, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 128, 192, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 252, 252, 248, 248, 249, 249, 249, 253, 253, 254, 254, 255, 255, 255, 255, 255, 248, 248, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 248, 248, 252, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 252, 248, 248, 249, 249, 249, 249, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255, 127, 127,  63,  63,  31,  15,   7,   3,   1,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   1,   1,   3,   3,   3,   3,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7, 135, 135, 199, 199, 199, 199, 199, 135, 135,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   3,   3,   3,   3,   1,   1,   1,   0, 128, 192, 192,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 112, 252, 166,  34,  34,  34,  34,  62,  60,   0,   0, 126, 255, 255, 129, 128,   0,   0,   0, 129, 195, 195, 195,   0, 200, 236, 238, 102,  38,  54, 254, 252, 252,   0, 156, 188, 190,  54, 118, 102, 238, 236, 192,   0,   1, 255, 255,  12,   4,   6,   6, 254, 252, 248,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   1,   3,   2,   2,   3,   1,   1,   0,   0,   0,   0,   1,   1,   3,   3,   3,   3,   3,   1,   1,   0,   0,   1,   3,   3,   3,   3,   3,   1,   3,   3,   0,   1,   3,   3,   3,   3,   3,   3,   3,   1,   0,   1,   3,   3,   0,   0,   0,   0,   3,   3,   3,   0,   0,   0,   0,   0,   0,   0
};

const unsigned char interswitchlogo[1024] = {
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 128, 192, 192, 192, 128, 128,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 128, 128, 192, 192, 192, 224, 224, 192,   0,   0,   0,   0, 126, 255, 255, 255, 255, 255, 255, 255,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,  96, 112,  56, 188, 190, 159, 223, 223, 207, 207, 207, 207, 239, 239, 224, 224, 224, 224, 224, 193, 195,   7,   7,   3,   3,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,  12,  61, 121, 249, 251, 243, 227, 231, 199,  31, 255, 255, 255, 255, 255, 255, 255, 127,  31,   0,   0, 224, 224, 224,  32,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 128, 128, 192,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 240, 240, 240,   0,   0,   0,   0, 192, 192, 192,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 192, 248, 248,  56,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0, 129, 255, 255, 255, 255,  15, 240, 255, 255, 255, 255, 127,  31,   7,   0,   0,   0, 248, 255, 255,  31,   0,   0, 248, 248, 120,  48,  56,  56, 248, 240,   0,   0,  56, 184, 255, 255,  63,  56,  56,  24, 192, 240, 240,  56,  24, 248, 248, 240,   0,   0, 224, 248, 248,  56,  24,  56,  56,   0, 240, 248, 152,   8,  24,  24,  56,  24,   0, 248, 248, 248,   0, 128, 224, 248, 248,   0,   0, 224, 248, 120,   8, 128, 248, 248, 120,   0,   0,  24, 152, 254, 255,  63,  24,  24,   8, 192, 240, 248,  56,  24,   8,  28,  28,   0, 224, 255, 255,  63,  28,  28, 252, 252, 248,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0, 224, 255, 255,  31, 199, 248, 254, 255, 127,  31,   7,   1,   0,   0,   0,   0,   0, 240, 255, 255,   7,   0,   0, 252, 255,  63,   0,   0,   0, 252, 255,  63,   0,   0, 192, 255, 255,   7,   0,   0,   0, 255, 255, 255,   6,   6, 134, 199,  71,   3,   0, 248, 255, 255,   1,   0,   0,   0,   0, 192, 131,   7,  15,  15, 255, 254, 124,   0,   0,  15, 255, 255, 124,  31,   3, 255, 255, 248,  63,  15,   1,   0, 192, 255, 255, 159,   0,   0,   0, 224, 255, 255, 159,   0,   0,   0, 126, 255, 255, 193, 128, 128, 192,  96,   0, 240, 255, 255,   7,   0,   0, 252, 255, 255,   3,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0, 124,  63, 207, 240, 254,  63,  31,   7,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   7,   3,   0,   0,   2,   3,   3,   0,   0,   0,   3,   3,   3,   0,   0,   0,   1,   3,   3,   3,   2,   0,   0,   1,   3,   3,   3,   3,   3,   1,   0,   0,   0,   3,   3,   3,   0,   0,   0,   0,   0,   3,   3,   7,   6,   3,   3,   1,   0,   0,   0,   0,   3,   3,   0,   0,   0,   1,   3,   3,   0,   0,   0,   0,   0,   3,   3,   3,   3,   0,   0,   0,   3,   3,   3,   3,   0,   0,   0,   1,   3,   3,   3,   3,   0,   0,   0,   3,   3,   3,   0,   0,   0,   3,   3,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   3,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0
};


#define bit_set(a,b) ((a) |= (1<<(b)))
#define bit_clear(a,b) ((a) &= ~(1<<(b)))
#define bit_test(a,b) ((a) & (1<<(b)))


void UpdateScreen();
 unsigned char memoryCopy(const unsigned char* copy) ;

void clearSetBuffer(unsigned char value) ;
 void glcd_pixel(int x, int y, unsigned char color)  ;
void glcd_text57(int x, int y, int size, unsigned char color, char* textptr);
void glcd_text87(int x, int y, int size, unsigned char color, char* textptr);
 void glcd_line1(int x1, int y1, int x2, int y2, unsigned char color);
 void glcd_rect(int x1, int y1, int x2, int y2, unsigned char fill, unsigned char color);
 void glcd_circle1(int x, int y, int radius, unsigned char fill, unsigned char color);
 void textbox(unsigned char y_position, unsigned char* title, unsigned char* value);
  void uart_received();

   unsigned char setTime(unsigned char setMin, unsigned char setHour, unsigned char setDay, unsigned char setDate, unsigned char setMonth, unsigned char setYear); // 227
 unsigned char getTime() ; // 228
 unsigned short read_ds1307(unsigned short address);
 unsigned char BCD2UpperCh(unsigned char bcd);
 unsigned char BCD2LowerCh(unsigned char bcd);
 void write_ds1307(unsigned short address,unsigned short w_data);

 void buzzerKeypad();

   unsigned char uart_received = 0;
  int mm;
  unsigned char updateRequired = 0,executeRequired = 0;
   unsigned char Value1[5];
unsigned char AmountText[20], PasswordText[20];

 unsigned char continueTransaction = 0 ;
 //  long TimeOut = 10;

 unsigned char memoryCopy(const unsigned char* copy) {
  for (mm = 0; mm < 1024; mm++) {
    display[mm] = copy[mm];
  }
 }

void clearSetBuffer(unsigned char value) {
  for (mm = 0; mm < 1024; mm++) {
    display[mm] = value;
  }
}


 void glcd_pixel(int x, int y, unsigned char color)
{
   unsigned char dataa;
   int calc;
   calc =  x + ((y/8) * 128) ;
   dataa = display[calc]  ;

   if(color == ON)
      bit_set(dataa, y%8);        // Turn the pixel on
   else                          // or
      bit_clear(dataa, y%8);      // turn the pixel off

    display[calc]   =  dataa ;
}

/*
void glcd_text35(int x, int y,
int size, unsigned char color, char* textptr)
{
   int i, j, k, l, m , count;                     // Loop counters
   unsigned char pixelData[3];                     // Stores character data

  for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string
   {
      if ((textptr[i] < '~') && (textptr[i] >= ' '))  // Checks if the letter is in the first text array
        {
         for (count = 0; count < 3; count++) {
//          pixelData[count] = TEXT[(textptr[i]-' ') + count];
         // pixelData[count] = textTest[count];
          pixelData[count] = TEXT3[(textptr[i] - 32)][count];
         }
         }

      else
      {
       for (count = 0; count < 3; count++) {
          pixelData[count] = TEXT3[0][count];
         }
      }

      if(x+3*size >= GLCD_WIDTH)          // Performs character wrapping
      {
         x = 0;                           // Set x at far left position
         y += 5*size + 1;                 // Set y at next position down
      }
      for(j=0; j<3; ++j, x+=size)         // Loop through character byte data
      {
         for(k=0; k<5*size; ++k)          // Loop through the vertical pixels
         {
            if(bit_test(pixelData[j], k)) // Check if the pixel should be set
            {
               for(l=0; l<size; ++l)      // The next two loops change the
               {                          // character's size
                  for(m=0; m<size; ++m)
                  {
                     glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel
                    //Glcd_Dot(x+m, y+k*size+l, color);
                  }
               }
            }
         }
      }
   }
}
  */



// Purpose:       Write text on a graphic LCD
// Inputs:        (x,y) - The upper left coordinate of the first letter
//                textptr - A pointer to an array of text to display
//                size - The size of the text: 1 = 5x7, 2 = 10x14, ...
//                color - ON or OFF

void glcd_text35(int x, int y,
int size, unsigned char color, char* textptr)
{
   int i, j, k, l, m , count;                     // Loop counters
   unsigned char pixelData[3];                     // Stores character data

  for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string
   {
      if ((textptr[i] < '~') && (textptr[i] >= ' '))  // Checks if the letter is in the first text array
        {
         for (count = 0; count < 3; count++) {
//          pixelData[count] = TEXT[(textptr[i]-' ') + count];
         // pixelData[count] = textTest[count];
          pixelData[count] = TEXT3[(textptr[i] - 32)][count];
         }
         }

      else
      {
       for (count = 0; count < 3; count++) {
          pixelData[count] = TEXT3[0][count];
         }
      }

      if(x+3*size >= GLCD_WIDTH)          // Performs character wrapping
      {
         x = 0;                           // Set x at far left position
         y += 7*size + 1;                 // Set y at next position down
      }
      for(j=0; j<3; ++j, x+=size)         // Loop through character byte data
      {
         for(k=0; k<7*size; ++k)          // Loop through the vertical pixels
         {
            if(bit_test(pixelData[j], k)) // Check if the pixel should be set
            {
               for(l=0; l<size; ++l)      // The next two loops change the
               {                          // character's size
                  for(m=0; m<size; ++m)
                  {
                     glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel
                    //Glcd_Dot(x+m, y+k*size+l, color);
                  }
               }
            }
         }
      }
   }
}


// Purpose:       Write text on a graphic LCD
// Inputs:        (x,y) - The upper left coordinate of the first letter
//                textptr - A pointer to an array of text to display
//                size - The size of the text: 1 = 5x7, 2 = 10x14, ...
//                color - ON or OFF

void glcd_text57(int x, int y,
int size, unsigned char color, char* textptr)
{
   int i, j, k, l, m , count;                     // Loop counters
   unsigned char pixelData[5];                     // Stores character data

  for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string
   {
      if ((textptr[i] < '~') && (textptr[i] >= ' '))  // Checks if the letter is in the first text array
        {
         for (count = 0; count < 5; count++) {
//          pixelData[count] = TEXT[(textptr[i]-' ') + count];
         // pixelData[count] = textTest[count];
          pixelData[count] = TEXT[(textptr[i] - 32)][count];
         }
         }

      else
      {
       for (count = 0; count < 5; count++) {
          pixelData[count] = TEXT[0][count];
         }
      }

      if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping
      {
         x = 0;                           // Set x at far left position
         y += 7*size + 1;                 // Set y at next position down
      }
      for(j=0; j<5; ++j, x+=size)         // Loop through character byte data
      {
         for(k=0; k<7*size; ++k)          // Loop through the vertical pixels
         {
            if(bit_test(pixelData[j], k)) // Check if the pixel should be set
            {
               for(l=0; l<size; ++l)      // The next two loops change the
               {                          // character's size
                  for(m=0; m<size; ++m)
                  {
                     glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel
                    //Glcd_Dot(x+m, y+k*size+l, color);
                  }
               }
            }
         }
      }
   }
}


void glcd_text87(int x, int y, int size, unsigned char color, char* textptr)
{
   int i, j, k, l, m , count;                     // Loop counters
   unsigned char pixelData[8];                     // Stores character data

  for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string
   {
      if ((textptr[i] < '~') && (textptr[i] >= ' '))  // Checks if the letter is in the first text array
        {
         for (count = 0; count < 8; count++) {
//          pixelData[count] = TEXT[(textptr[i]-' ') + count];
         // pixelData[count] = textTest[count];
          pixelData[count] = TEXT2[(textptr[i] - 32)][count];
         }
         }

      else
      {
       for (count = 0; count < 8; count++) {
          pixelData[count] = TEXT2[0][count];
         }
      }

      if(x+8*size >= GLCD_WIDTH)          // Performs character wrapping
      {
         x = 0;                           // Set x at far left position
         y += 7*size + 1;                 // Set y at next position down
      }
      for(j=0; j<8; ++j, x+=size)         // Loop through character byte data
      {
         for(k=0; k<7*size; ++k)          // Loop through the vertical pixels
         {
            if(bit_test(pixelData[j], k)) // Check if the pixel should be set
            {
               for(l=0; l<size; ++l)      // The next two loops change the
               {                          // character's size
                  for(m=0; m<size; ++m)
                  {
                     glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel
                    //Glcd_Dot(x+m, y+k*size+l, color);
                  }
               }
            }
         }
      }
   }
}


 unsigned char checkKeypad(long timeout, unsigned char* value) {
   unsigned short kp;
   long timeCount = 0, TimeOutCalc;
   TimeOutCalc =(10000 * timeout)  ;
    kp = 0;                                // Reset key code variable
   // Wait for key to be pressed and released
    do {
      // kp = Keypad_Key_Press();          // Store key code in kp variable
      kp = Keypad_Key_Click();             // Store key code in kp variable
        delay_us(100);
      timeCount++;
      if (timeCount > TimeOutCalc) {
        *value = 0;
        return 0;
      }
  }  while (!kp);
    buzzerKeypad();
     *value = kp;
     return 1;

 }

 unsigned char checkKeypadDummy(long timeout, unsigned char* value) {
   unsigned short kp;
   long timeCount = 0, TimeOutCalc;
   TimeOutCalc =(10000 * timeout)  ;
    kp = 0;                                // Reset key code variable
   // Wait for key to be pressed and released
    do {
      // kp = Keypad_Key_Press();          // Store key code in kp variable
      kp = Keypad_Key_Click();             // Store key code in kp variable
        delay_us(100);
      timeCount++;
      if (timeCount > TimeOutCalc) {
        *value = 0;
        return 0;
      }
       getTime();
  clearSetBuffer(0);
glcd_text57(5, 20, 1, 1, time);
glcd_text57(5, 30, 1, 1, ddate);
UpdateScreen();
delay_ms(200);
  }  while (!kp);

     *value = kp;
     return 1;

 }

unsigned char keypadAmountPassword(unsigned char y1,unsigned char passwordAmount,unsigned char* title) {
  unsigned char valueInput;
long timeoutSec;
  unsigned char count = 0;
  unsigned char Value, numb;
   unsigned short kp;
   int timeCount = 0;
 continueTransaction = 0    ;
  updateRequired = 0;
  executeRequired = 0;
  memset(AmountText,'\0',20);
  memset(PasswordText,'\0',20);

  if (!passwordAmount) {
  AmountText[0] = '0';
  AmountText[1] = '.';
  AmountText[2] = '0';
  AmountText[3] = '0';
  AmountText[4] = '\0';

 clearSetBuffer(0);

 textbox(y1,title, AmountText);
 UpdateScreen();
    }

    else if (passwordAmount) {
 clearSetBuffer(0);
 textbox(y1,title, PasswordText);
 UpdateScreen();

    }
  while(1) {
  timeOutSec = 10;
  if (checkKeypad(timeOutSec, &Value)) {
      switch (value) {

      case  1: valueInput = '1'; count++; updateRequired = 1; break; // 1    # 1    // Uncomment this block for keypad4x4
      case  2: valueInput = '4'; count++; updateRequired = 1; break; // 2   #4
      case  3: valueInput = '7'; count++; updateRequired = 1; break; // 3  # 7
      case  4: valueInput = 'X';
      if (!passwordAmount) {
      if (count >= 3) {
       AmountText[count+1] = valueInput;
       AmountText[count+2] = '\0';
      }
      else {
       AmountText[4] = valueInput;
       AmountText[5] = '\0';
      }
      }
      else if (passwordAmount) {
      AmountText[count] = valueInput;
       AmountText[count+1] = '\0';
      }
      executeRequired = 1; break; // A  # CANCEL (X)
      case  5: valueInput = '2'; count++; updateRequired = 1; break; // 4    # 2
      case  6: valueInput = '5'; count++; updateRequired = 1; break; // 5    # 5
      case  7: valueInput = '8'; count++; updateRequired = 1; break; // 6    # 8
      case  8: valueInput = '0'; count++; updateRequired = 1; break; // B   # 0
      case  9: valueInput = '3'; count++; updateRequired = 1; break; // 7    #3
      case 10: valueInput = '6'; count++; updateRequired = 1; break; // 8    #6
      case 11: valueInput = '9'; count++; updateRequired = 1; break; // 9    #9
      case 12: valueInput = 'C';
      count = 0;
  memset(AmountText,'\0',20);
  memset(PasswordText,'\0',20);
  if (!passwordAmount) {
        AmountText[0] = '0';
  AmountText[1] = '.';
  AmountText[2] = '0';
  AmountText[3] = '0';
  AmountText[4] = '\0';
  }
  updateRequired = 0;
  executeRequired = 0;
 clearSetBuffer(0);
 textbox(y1,title, AmountText);
 UpdateScreen();
       break; // C   # CLEAR (C)
      case 13:  break; // *
      case 14:  break; // 0
      case 15: valueInput = 'M'; count++; updateRequired = 1; break; // #    # MENU (M)
      case 16: valueInput = 'E';
 if (!passwordAmount) {
      if (count >= 3) {
       AmountText[count+1] = valueInput;
       AmountText[count+2] = '\0';
      }
      else {
       AmountText[4] = valueInput;
       AmountText[5] = '\0';
      }
      }
      else if (passwordAmount) {
      AmountText[count] = valueInput;
       AmountText[count+1] = '\0';
      }
      executeRequired = 1; break; // D   # ENTER (E)

      }
     if (updateRequired) {
      if (passwordAmount) {
      if (count > 0) {
      AmountText[count-1] = valueInput;
      PasswordText[count-1] = '*';
      AmountText[count] = '\0';
      PasswordText[count] = '\0';
      clearSetBuffer(0);
      textbox(y1,title, PasswordText);
      UpdateScreen();
      }
      }
      else if (!passwordAmount) {
          if (count == 1) {
      AmountText[3] = valueInput;
      }
      else if (count == 2) {
      AmountText[2] = AmountText[3];
      AmountText[3] = valueInput;
      }
      else if (count == 3) {
      AmountText[0] = AmountText[2];
      AmountText[2] = AmountText[3];
      AmountText[3] = valueInput;
      }
      else if (count > 3) {
      AmountText[count] = valueInput;
      AmountText[count-3] = AmountText[count-2];
      AmountText[count-2] = '.';
      AmountText[count+1] = '\0';
      }
 clearSetBuffer(0);
 textbox(y1,title, AmountText);
 UpdateScreen();
      }
     updateRequired = 0;
     }

     if (executeRequired) {
      if (valueInput == 'E') {
      continueTransaction = 1;
      UART1_Write(246);
      delay_ms(5);
      for (kp = 0; kp < (count+1); kp++) {
      UART1_Write(AmountText[kp]);
      delay_ms(5);
      }
      UART1_Write(248);
      delay_ms(5);
      break;
      }
      else if (valueInput == 'X') {
      continueTransaction = 0;
      UART1_Write(246);
      delay_ms(5);
      for (kp = 0; kp < (count+1); kp++) {
      UART1_Write(AmountText[kp]);
      delay_ms(5);
      }
      UART1_Write(248);
      delay_ms(5);
       break;
      }
     }
     }
     else {
      continueTransaction = 0;
      UART1_Write(246);
      delay_ms(5);
      UART1_Write(247);  // timeout
      delay_ms(5);
      UART1_Write(248);
      delay_ms(5);
       break;
     }
  }
 }


 unsigned char keypadMenu() {
  unsigned char valueInput;
long timeoutSec;
  unsigned char count = 0;
  unsigned char Value;
   int timeCount = 0;

 //  unsigned char key[3] = {'\0','\0','\0'};
 continueTransaction = 0;
 updateRequired = 0;
 executeRequired = 0;

    while(1) {
  timeOutSec = 10;
  if (checkKeypad(timeOutSec, &Value)) {
      switch (Value) {

      case  1: valueInput = '1';  updateRequired = 1; break; // 1    # 1    // Uncomment this block for keypad4x4
      case  2: valueInput = '4';  updateRequired = 1; break; // 2   #4
      case  3:  break; // 3  # 7
      case  4: valueInput = 'X';
      updateRequired = 1; break; // A  # CANCEL (X)
      case  5: valueInput = '2'; updateRequired = 1; break; // 4    # 2
      case  6:  break; // 5    # 5
      case  7: break; // 6    # 8
      case  8:  break; // B   # 0
      case  9: valueInput = '3'; updateRequired = 1; break; // 7    #3
      case 10: break; // 8    #6
      case 11:  break; // 9    #9
      case 12: break; // C   # CLEAR (C)
      case 13:  break; // *
      case 14:  break; // 0
      case 15: valueInput = 'M'; updateRequired = 1; break; // #    # MENU (M)
      case 16: valueInput = 'E';
      updateRequired = 1; break; // D   # ENTER (E)

      }
     if (updateRequired) {

//     clearSetBuffer(0);
//     UpdateScreen();
     updateRequired = 0;
     continueTransaction = 1;
     memset(Value1,'\0',5);
     Value1[0] = valueInput;
      UART1_Write(246);
delay_ms(5);
      UART1_Write(valueInput);
delay_ms(5);
      UART1_Write(248);
      delay_ms(5);
      break;
     }
     }
     else {
      continueTransaction = 0;
      UART1_Write(246);
      delay_ms(5);
      UART1_Write(247);  // timeout
      delay_ms(5);
      UART1_Write(248);
      delay_ms(5);
      break;
     }
  }
 }



 unsigned char dummyDisplay() {
  unsigned char valueInput;
long timeoutSec;
  unsigned char count = 0;
  unsigned char Value;
   int timeCount = 0;

 //  unsigned char key[3] = {'\0','\0','\0'};
 continueTransaction = 0;
 updateRequired = 0;
 executeRequired = 0;

    while(1) {
  timeOutSec = 10;
  if (checkKeypad(timeOutSec, &Value)) {
      switch (Value) {

      case  1: valueInput = '1';  updateRequired = 1; break; // 1    # 1    // Uncomment this block for keypad4x4
      case  2: valueInput = '4';  updateRequired = 1; break; // 2   #4
      case  3:  break; // 3  # 7
      case  4: valueInput = 'X';
      updateRequired = 1; break; // A  # CANCEL (X)
      case  5: valueInput = '2'; updateRequired = 1; break; // 4    # 2
      case  6:  break; // 5    # 5
      case  7: break; // 6    # 8
      case  8:  break; // B   # 0
      case  9: valueInput = '3'; updateRequired = 1; break; // 7    #3
      case 10: break; // 8    #6
      case 11:  break; // 9    #9
      case 12: break; // C   # CLEAR (C)
      case 13:  break; // *
      case 14:  break; // 0
      case 15: valueInput = 'M'; updateRequired = 1; break; // #    # MENU (M)
      case 16: valueInput = 'E';
      updateRequired = 1; break; // D   # ENTER (E)

      }
     if (updateRequired) {

//     clearSetBuffer(0);
//     UpdateScreen();
     updateRequired = 0;
     continueTransaction = 1;
     memset(Value1,'\0',5);
     Value1[0] = valueInput;
      UART1_Write(246);
delay_ms(5);
      UART1_Write(valueInput);
delay_ms(5);
      UART1_Write(248);
      delay_ms(5);
      break;
     }
     }
     else {
      continueTransaction = 0;
      UART1_Write(246);
      delay_ms(5);
      UART1_Write(247);  // timeout
      delay_ms(5);
      UART1_Write(248);
      delay_ms(5);
      break;
     }
  }
 }


void menu(unsigned short position, unsigned short color, unsigned char checked, unsigned char* text) {
  unsigned char y_upper_left, x_upper_left = 5;
 if (position == 0) {
  y_upper_left = 6;
  }
  else if((position < 4) && (position > 0)) {
  y_upper_left = 6 + (2 * position) + (position * 12);
  }

   glcd_text57(x_upper_left + 2,y_upper_left + 3, 1, color, text);
    glcd_rect(x_upper_left,y_upper_left,110,y_upper_left + 12,NO,color);
    glcd_rect(100,y_upper_left + 2,107,y_upper_left + 9,NO,color);
    if (checked) {
    glcd_rect(102,y_upper_left + 4,105,y_upper_left + 7,YES,color);
    }
 }
/*
 void textbox(unsigned char y_position, unsigned char* title, unsigned char* value) {
 unsigned char size_text, x_position;
 glcd_text57(20, y_position, title, 1, 1);
 glcd_rect(10,y_position + 11,110,y_position + 22,NO,1);
 glcd_text57(15, y_position + 14, value, 1, 1);

 }
  */
 void textbox(unsigned char y_position, unsigned char* title, unsigned char* value) {
 unsigned char size_text, x_position;
 glcd_text57(20, y_position, 1, 1, title);
 glcd_rect(10,y_position + 11,110,y_position + 22,NO,1);
 glcd_text57(15, y_position + 14, 1, 1, value);
 }


// Purpose:       Draw a line on a graphic LCD using Bresenham's
//                line drawing algorithm
// Inputs:        (x1, y1) - the start coordinate
//                (x2, y2) - the end coordinate
//                color - ON or OFF
// Dependencies:  glcd_pixel()
void glcd_line1(int x1, int y1, int x2, int y2, unsigned char color)
{
   signed int  x, y, addx, addy, dx, dy;
   signed long P;
   int i;
   dx = abs((signed int)(x2 - x1));
   dy = abs((signed int)(y2 - y1));
   x = x1;
   y = y1;

   if(x1 > x2)
      addx = -1;
   else
      addx = 1;
   if(y1 > y2)
      addy = -1;
   else
      addy = 1;

   if(dx >= dy)
   {
      P = 2*dy - dx;

      for(i=0; i<=dx; ++i)
      {
         glcd_pixel(x, y, color);

         if(P < 0)
         {
            P += 2*dy;
            x += addx;
         }
         else
         {
            P += 2*dy - 2*dx;
            x += addx;
            y += addy;
         }
      }
   }
   else
   {
      P = 2*dx - dy;

      for(i=0; i<=dy; ++i)
      {
         glcd_pixel(x, y, color);

         if(P < 0)
         {
            P += 2*dx;
            y += addy;
         }
         else
         {
            P += 2*dx - 2*dy;
            x += addx;
            y += addy;
         }
      }
   }
}



// Purpose:       Draw a rectangle on a graphic LCD
// Inputs:        (x1, y1) - the start coordinate
//                (x2, y2) - the end coordinate
//                fill  - YES or NO
//                color - ON or OFF
// Dependencies:  glcd_pixel(), glcd_line()
void glcd_rect(int x1, int y1, int x2, int y2, unsigned char fill, unsigned char color)
{
   if(fill)
   {
      int y, ymax;                          // Find the y min and max
      if(y1 < y2)
      {
         y = y1;
         ymax = y2;
      }
      else
      {
         y = y2;
         ymax = y1;
      }

      for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle
         glcd_line1(x1, y, x2, y, color);
   }
   else
   {
      glcd_line1(x1, y1, x2, y1, color);      // Draw the 4 sides
      glcd_line1(x1, y2, x2, y2, color);
      glcd_line1(x1, y1, x1, y2, color);
      glcd_line1(x2, y1, x2, y2, color);
   }
}



// Purpose:       Draw a circle on a graphic LCD
// Inputs:        (x,y) - the center of the circle
//                radius - the radius of the circle
//                fill - YES or NO
//                color - ON or OFF
void glcd_circle1(int x, int y, int radius, unsigned char fill, unsigned char color)
{
   signed int a, b, P;
   a = 0;
   b = radius;
   P = 1 - radius;

   do
   {
      if(fill)
      {
         glcd_line1(x-a, y+b, x+a, y+b, color);
         glcd_line1(x-a, y-b, x+a, y-b, color);
         glcd_line1(x-b, y+a, x+b, y+a, color);
         glcd_line1(x-b, y-a, x+b, y-a, color);
      }
      else
      {
         glcd_pixel(a+x, b+y, color);
         glcd_pixel(b+x, a+y, color);
         glcd_pixel(x-a, b+y, color);
         glcd_pixel(x-b, a+y, color);
         glcd_pixel(b+x, y-a, color);
         glcd_pixel(a+x, y-b, color);
         glcd_pixel(x-a, y-b, color);
         glcd_pixel(x-b, y-a, color);
      }

      if(P < 0)
         P+= 3 + 2*a++;
      else
         P+= 5 + 2*(a++ - b--);
    } while(a <= b);
}


void UpdateScreen()  //Change here for method 1,2 and 3
{
unsigned char *ip = display;
int Page, Column;
//ip += 1024;
     for (Page = 0; Page < 8; Page++)
    {
// Glcd_Select_Side(0);
    Glcd_Dot(0, 0, 0);
    Glcd_Set_X(0);
 Glcd_Set_Page(page);

 for (Column = 0; Column < 128; Column++)
     {
        if (Column == 64)
        {
    Glcd_Dot(64, 0, 0);
    Glcd_Set_X(0);
 Glcd_Set_Page(page);
       }

         if (Column < 64) {
Glcd_Write_Data(*ip++);
          }
          else {
Glcd_Write_Data(*ip++);

          }

     }
    }
}

 unsigned char setTime(unsigned char setMin, unsigned char setHour, unsigned char setDay, unsigned char setDate, unsigned char setMonth, unsigned char setYear) {
  //Set Time
write_ds1307(0,0x80); //Reset second to 0 sec. and stop Oscillator
write_ds1307(1,setMin); //write min 27
write_ds1307(2,setHour); //write hour 14
write_ds1307(3,setDay); //write day of week 2:Monday
write_ds1307(4,setDate); // write date 17
write_ds1307(5,setMonth); // write month 6 June
write_ds1307(6,setYear); // write year 8 --> 2008
write_ds1307(7,0x10); //SQWE output at 1 Hz
write_ds1307(0,0x00); //Reset second to 0 sec. and start Oscillator

 }

unsigned short read_ds1307(unsigned short address)
{
Soft_I2C_Start();
Soft_I2C_Write(0xd0); //address 0x68 followed by direction bit (0 for write, 1 for read) 0x68 followed by 0 --> 0xD0
Soft_I2C_Write(address);
//I2C_Repeated_Start();
Soft_I2C_Start();
Soft_I2C_Write(0xd1); //0x68 followed by 1 --> 0xD1
dataa=Soft_I2C_Read(0);
 Soft_I2C_Stop();
return(dataa);
}

unsigned char BCD2UpperCh(unsigned char bcd)
{
return ((bcd >> 4) + '0');
}

unsigned char BCD2LowerCh(unsigned char bcd)
{
return ((bcd & 0x0F) + '0');
}
void write_ds1307(unsigned short address,unsigned short w_data)
{
Soft_I2C_Start(); // issue I2C start signal
//address 0x68 followed by direction bit (0 for write, 1 for read) 0x68 followed by 0 --> 0xD0
Soft_I2C_Write(0xD0); // send byte via I2C (device address + W)
Soft_I2C_Write(address); // send byte (address of DS1307 location)
Soft_I2C_Write(w_data); // send data (data to be written)
 Soft_I2C_Stop();
}

unsigned char getTime() {
sec=read_ds1307(0); // read second
minute=read_ds1307(1); // read minute
hour=read_ds1307(2); // read hour
day=read_ds1307(3); // read day
date=read_ds1307(4); // read date
month=read_ds1307(5); // read month
year=read_ds1307(6); // read year

time[0] = BCD2UpperCh(hour);
time[1] = BCD2LowerCh(hour);
time[2] = ':';
time[3] = BCD2UpperCh(minute);
time[4] = BCD2LowerCh(minute);
time[5] = ':';
time[6] = BCD2UpperCh(sec);
time[7] = BCD2LowerCh(sec);
time[8] = '\0';

ddate[0] = BCD2UpperCh(date);
ddate[1] = BCD2LowerCh(date);
ddate[2] ='/';
ddate[3] = BCD2UpperCh(month);
ddate[4] = BCD2LowerCh(month);
ddate[5] ='/';
ddate[6] = '2';
ddate[7] = '0';
ddate[8] = BCD2UpperCh(year);
ddate[9] = BCD2LowerCh(year);
ddate[10] = '\0';
      UART1_Write(246);
      delay_ms(5);
//      for (kp = 0; kp < (count+1); kp++) {
        for (kp = 0; kp < strlen(time); kp++) {
    UART1_Write(time[kp]);
      delay_ms(5);
      }
       UART1_Write('^');
      delay_ms(5);
         for (kp = 0; kp < strlen(ddate); kp++) {
    UART1_Write(ddate[kp]);
      delay_ms(5);
      }
      UART1_Write(248);
      delay_ms(5);

}


void interrupt() {
 if (PIR1.RCIF) {
      uart_rd = UART1_Read();     // read the received data,

     if ((uart_rd >=202) && (uart_rd < 230)) {
      isCommand = 1;
      cmd = uart_rd;
      isEndData = 0;
      countuart = 0;
     }
      else if (isCommand && (uart_rd == 200)) {
      isStartData = 1;
      isEndData = 0;
      countuart = 0;
     }
        else if (isCommand && isStartData && (uart_rd != 201)) {
      data1[countuart] = uart_rd;
      isEndData = 0;
      countuart++;
     }
     else if (isCommand && isStartData && (uart_rd == 201)) {
      isCommand = 0;
      isStartData = 0;
      isEndData = 1;
     }
 }
}

void buzzerKeypad() {
   PORTC.F2 = 1;
  delay_ms(50);
  PORTC.F2 = 0;
}



void main() {
 unsigned char u,v,kp;
  unsigned char x1,y1,x2,y2;
  unsigned char ii;
  char *someText;
  unsigned char testing[50], counting = 0;
  int timeCount;
  unsigned char amount = 0;
  delay_ms(2000);
ADCON1 = 0b10000111;
TRISC.F2 = 0;
   TRISE.F0 = 0;
 PORTE.F0 = 1;
 PORTC.F2 = 0;
buzzerKeypad();
delay_ms(1000);

buzzerKeypad();
delay_ms(1000);
buzzerKeypad();
delay_ms(1000);

  Keypad_Init();
  Soft_I2C_Init();

  Glcd_Init();
   INTCON.GIE = 1;
  INTCON.PEIE = 1;
  PIE1.RCIE = 1;
  UART1_Init(9600);               // Initialize UART module at 9600 bps
  Delay_ms(100);                                                    // Initialize GLCD

                           // Initialize GLCD
 clearSetBuffer(0);
 UpdateScreen();
 delay_ms(200);
 clearSetBuffer(0);
  glcd_text87(20,10, 1,1, "STARTING");
  glcd_text87(20,20, 1,1, "ANDROMEDA");
  glcd_text57(20,40, 1,1, "PLEASE WAIT ...");
 UpdateScreen();

while (1) {                     // Endless loop
   if (isEndData == 1) {
   switch (cmd) {
    case 214:
     if (countuart == 1) {
       clearSetBuffer(data1[0]);
       }
    isEndData = 0;
       countuart = 0;
       break;

    case 215:
     if (countuart == 3) {
       data2[0] = data1[0];
       data2[1] = data1[1];
       data2[2] = data1[2];
       glcd_pixel(data2[0], data2[1], data2[2]);
       }
    isEndData = 0;
       countuart = 0;
       break;


    case 216:
     if (countuart > 3) {
       data2[0] = data1[0];
       data2[1] = data1[1];
       data2[2] = data1[2];
       data2[3] = data1[3];

       for (counter = 0; counter < (countuart -4); counter++) {
        data1[counter] = data1[counter +4];
       }
       data1[countuart -4] = '\0';
       data1[countuart -3] = '\0';
       data1[countuart -2] = '\0';
       data1[countuart -1] = '\0';
       glcd_text57(data2[0], data2[1], data2[2],data2[3], data1);
       }
    isEndData = 0;
       countuart = 0;
       break;

    case 217:
     if (countuart > 3) {
       data2[0] = data1[0];
       data2[1] = data1[1];
       data2[2] = data1[2];
       data2[3] = data1[3];

       for (counter = 0; counter < (countuart -4); counter++) {
        data1[counter] = data1[counter +4];
       }
       data1[countuart -4] = '\0';
       data1[countuart -3] = '\0';
       data1[countuart -2] = '\0';
       data1[countuart -1] = '\0';
       glcd_text87(data2[0], data2[1], data2[2],data2[3], data1);
       }
    isEndData = 0;
       countuart = 0;
       break;

    case 218:
     if (countuart > 3) {
       data2[0] = data1[0];
       data2[1] = data1[1];
       data2[2] = data1[2];
       data2[3] = data1[3];

       for (counter = 0; counter < (countuart -4); counter++) {
        data1[counter] = data1[counter +4];
       }
       data1[countuart -4] = '\0';
       data1[countuart -3] = '\0';
       data1[countuart -2] = '\0';
       data1[countuart -1] = '\0';
       glcd_text35(data2[0], data2[1], data2[2],data2[3], data1);
       }
    isEndData = 0;
       countuart = 0;
       break;


    case 219:
     if (countuart > 2) {
       data2[0] = data1[0];
       data2[1] = data1[1];
       for (counter = 0; counter < (countuart -2); counter++) {
        data1[counter] = data1[counter +2];
       }
       data1[countuart -2] = '\0';
       data1[countuart -1] = '\0';
       keypadAmountPassword(data2[0], data2[1], data1);
       }
    isEndData = 0;
       countuart = 0;
       break;

    case 220:
     if (countuart == 0) {
       keypadMenu();
      }
    isEndData = 0;
       countuart = 0;
       break;

    case 221:
     if (countuart > 3) {
       data2[0] = data1[0];
       data2[1] = data1[1];
       data2[2] = data1[2];
       for (counter = 0; counter < (countuart -3); counter++) {
        data1[counter] = data1[counter +3];
       }
       data1[countuart -3] = '\0';
       data1[countuart -2] = '\0';
       data1[countuart -1] = '\0';
       menu(data2[0], data2[1], data2[2], data1);
       }
    isEndData = 0;
       countuart = 0;
       break;


    case 222:
     if (countuart > 2) {
       data2[0] = data1[0];
       for (counter = 0; counter < (countuart -1); counter++) {
        data1[counter] = data1[counter +1];
       }
       data1[countuart - 1] = '\0';
      for (counter = 0; counter < (countuart -1); counter++) {
        if (data1[counter] == 94) {
         data1[counter] = '\0';
         x1 = 20;
         y1 = 0;
         continue;
         }
         if (x1 == 20) {
         data3[y1] = data1[counter];
         y1++;
         }
       }
       data3[y1] = '\0';
       x1 = 0;
       textbox(data2[0], data1, data3);
       }
    isEndData = 0;
       countuart = 0;
       break;


    case 223:
     if (countuart == 5) {
       data2[0] = data1[0];
       data2[1] = data1[1];
       data2[2] = data1[2];
       data2[3] = data1[3];
       data2[4] = data1[4];
       glcd_line1(data2[0], data2[1], data2[2] , data2[3], data2[4]);
       }
    isEndData = 0;
       countuart = 0;
       break;


    case 224:
     if (countuart == 6) {
       glcd_rect(data1[0], data1[1], data1[2] , data1[3], data1[4], data1[5]);
       }
    isEndData = 0;
       countuart = 0;
       break;


    case 225:
     if (countuart == 5) {
       glcd_circle1(data1[0], data1[1], data1[2] , data1[3], data1[4]);
       }
    isEndData = 0;
       countuart = 0;
       break;

    case 226:
     if (countuart == 0) {
       UpdateScreen();
       }
    isEndData = 0;
       countuart = 0;
       break;

        case 228:
         if (countuart == 0) {
       getTime();
       }
    isEndData = 0;
       countuart = 0;
       break;

    case 227:
     if (countuart == 6) {
       setTime(data1[0], data1[1], data1[2] , data1[3], data1[4], data1[5]);
       }
    isEndData = 0;
       countuart = 0;
       break;


   }
     isEndData = 0;
    memset(data1,'\0',40);
        memset(data3,'\0',20);
            memset(data2,'\0',5);

   }

  }
}
